mdp

module prob_conformance

       die : [0..6];
       s   : [0..6];
       f   : [0..1];

        // the 6-sided die (f==0)
       [] (s=0)&(die=0)&(f=0) -> 1/6 : (die'=1) + 1/6 : (die'=2) + 1/6 : (die'=3) + 1/6 : (die'=4) + 1/6 : (die'=5) + 1/6 : (die'=6);
       [] (die!=0) -> true;

       // the 2-sided die policy to synthetize (f==1)
       // non determinism of state s0

       [g] (s=0)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=2);
       [h] (s=0)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=3);
       [i] (s=0)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=4);
       [j] (s=0)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=5);
       [k] (s=0)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=6);

       // nondeterminism of state s1
       [l] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=2) + 1/2 : (s'=3);
       [m] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=2) + 1/2 : (s'=4);
       [n] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=2) + 1/2 : (s'=5);
       [o] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=2) + 1/2 : (s'=6);

       [p] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=3) + 1/2 : (s'=4);
       [q] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=3) + 1/2 : (s'=5);
       [r] (s=1)&(die=0)&(f=1) -> 1/2 : (s'=3) + 1/2 : (s'=6);


       [] (s=2)&(die=0)&(f=1) -> 1/2 : (s'=5) + 1/2 : (s'=6);

       [] (s=3)&(die=0)&(f=1) -> 1/2 : (s'=1) + 1/2 : (s'=0)&(die'=1);

       [] (s=4)&(die=0)&(f=1) -> 1/2 : (s'=0)&(die'=2) + 1/2 : (s'=0)&(die'=3);

       [] (s=5)&(die=0)&(f=1) -> 1/2 : (s'=0)&(die'=4) + 1/2 : (s'=0)&(die'=5);

       [] (s=6)&(die=0)&(f=1) -> 1/2 : (s'=2) + 1/2 : (s'=0)&(die'=6);



endmodule

init  (s=0)&(die=0)  endinit

label "start1" = (s=0)&(die=0)&(f=0);
label "start2" = (s=0)&(die=0)&(f=1);

label "die1" = (die=1);
label "die2" = (die=2);
label "die3" = (die=3);
label "die4" = (die=4);
label "die5" = (die=5);
label "die6" = (die=6);